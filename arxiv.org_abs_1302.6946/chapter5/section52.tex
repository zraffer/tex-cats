\documentclass[../main/CT4S-EN-RU]{subfiles}

\begin{document}

\section{\caseENGRUS{Categories of functors}{ / }{ĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸ Ñ„ÑƒĞ½ĞºÑ‚Ğ¾Ñ€Ğ¾Ğ²}}

\begin{blockENG}
For any two categories ${ğ“’}$ and ${ğ““},$
\footnote{Technically ${ğ“’}$ has to be small (see Remark~\ref{rmk:small}), but as we said there, we are not worrying about that distinction in this book.}
we discussed the category $\Fun({ğ“’},{ğ““})$ of functors and natural transformations between them. In this section we discuss functor categories a bit more and give some important applications within mathematics (sheaves) that extend to the real world.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

%%%% Subsection %%%%

\subsection{\caseENGRUS{Set-valued functors}{ / }{ĞŸÑ€ĞµĞ´Ğ¿ÑƒÑ‡ĞºĞ¸}}

\begin{blockENG}
Let ${ğ“’}$ be a category. Then we have been writing ${ğ“’}\set$ to denote the functor category $\Fun({ğ“’},\Set).$ Here is a nice result about these categories.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{propositionENG}\label{prop:inst closed under colim lim}
Let ${ğ“’}$ be a category. The category ${ğ“’}\set$ is closed under colimits and limits.
\end{propositionENG}

\begin{propositionRUS}\label{prop:inst closed under colim lim}
\end{propositionRUS}

\begin{proofENG}[Sketch of proof]
Let $J$ be an indexing category and $D\colon J{â†’}{ğ“’}\set$ a functor. For each object $c\in\Ob({ğ“’}),$ we have a functor $D_c\colon J{â†’}\Set$ defined by $D_c(j)=D(j)(c).$ Define a functor $L\colon{ğ“’}{â†’}\Set$ by $L(c)=\lim_J D_c,$ and note that for each $f\colon c{â†’} c'$ in ${ğ“’}$ there is an induced function $L(f)\colon L(c){â†’} L(c').$ One can check that $L$ is a limit of $J,$ because it satisfies the relevant universal property. 

The dual proof holds for colimits.
\end{proofENG}

\begin{proofRUS}[Sketch of proof]
\end{proofRUS}

\begin{applicationENG}
When taking in data about a scientific subject, one often finds that the way one thinks about the problem changes over time. We understand this phenomenon in the language of databases in terms of a \href{http://en.wikipedia.org/wiki/Schema_evolution}{\text series of schemas} ${ğ“’}_1,{ğ“’}_2,\ldots,{ğ“’}_n,$ perhaps indexed chronologically. The problem is that old data is held in old schemas and we want to see it in our current understanding. The first step is to transfer all the old data to our new schema in the freest possible way, that is, making no assumptions about how to fill in the new fields. If one creates functors $F_i\colon{ğ“’}_i{â†’}{ğ“’}_{i+1}$ from each of these schemas to the next, then we can push the data forward using ${Î£}_{F_i}.$ 

Doing this we will have $n$ datasets on ${ğ““}{\coloneqq}{ğ“’}_n,$ namely one for each â€œepoch of understandingâ€. Since the category ${ğ““}\set$ has all colimits, we can take the union of these datasets and get one. It will have many Skolem variables (see Example~\ref{ex:left pushforward and skolem}), and these need to be handled in a coherent way. However, the universality of left adjoints could be interpreted as saying that any reasonable formula for handling this old data can be applied to our results.
\end{applicationENG}

\begin{applicationRUS}
\end{applicationRUS}

\begin{exerciseENG}\label{exc:universal objects in C-set}\index{initial object!in ${ğ“’}\set$}\index{terminal object!in ${ğ“’}\set$}
By Proposition~\ref{prop:inst closed under colim lim}, the category ${ğ“’}\set$ is closed under taking limits. By Exercises~\ref{exc:terminal as limit} and~\ref{exc:initial as colimit}, this means in particular that ${ğ“’}\set$ has an initial object and a terminal object. 
\sexc Let $A\in\Ob({ğ“’}\set)$ be the initial object, considered as a functor $A\colon{ğ“’}{â†’}\Set.$ For any $c\in\Ob({ğ“’}),$ what is the set $A(c)?$
\item Let $Z\in\Ob({ğ“’}\set)$ be the terminal object, considered as a functor $Z\colon{ğ“’}{â†’}\Set.$ For any $c\in\Ob({ğ“’}),$ what is the set $Z(c)?$
\endsexc
\end{exerciseENG}

\begin{exerciseRUS}\label{exc:universal objects in C-set}\index{initial object!in ${ğ“’}\set$}\index{terminal object!in ${ğ“’}\set$}
\end{exerciseRUS}

\begin{blockENG}
Proposition~\ref{prop:inst closed under colim lim} says that we can add or multiply database states together. In fact, database states on ${ğ“’}$ form what is called a {\em topos} which means that just about every consideration we made for sets holds for instances on any schema. Perhaps the simplest schema is ${ğ“’}=\fbox{$âˆ™$},$ on which the relevant topos is indeed $\Set.$ But schemas can be arbitrarily complex, and it is impressive that all of these considerations make sense in such generality. Here is a table that makes a comparison between these domains.
\begin{center}
\begin{tabular}{| l | l |}\bhline
\multicolumn{2}{| c |}{Dictionary between $\Set$ and ${ğ“’}\set$}\\\hline
{\bf Concept in $\Set$}&{\bf Concept in ${ğ“’}\set$}\\\bbhline
Set & Object in ${ğ“’}\set$\\\hline
Function & Morphism in ${ğ“’}\set$\\\hline
Element&Representable functor\\\hline
Empty set & Initial object\\\hline
Natural numbers&Natural numbers object\\\hline
Image&Image\\\hline
(Co)limits&(Co)limits\\\hline
Exponential objects&Exponential objects\\\hline
â€œFamiliarâ€ arithmetic&â€œFamiliarâ€ arithmetic\\\hline
Power sets $2^X$&Power objects $\Omega^X$\\\hline
Characteristic functions&Characteristic morphisms\\\hline
Surjections, injections&Epimorphisms, monomorphisms\\\bhline
\end{tabular}
\end{center}
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{blockENG}
In the above table we said that elements of a set are akin to representable functors in ${ğ“’}\set,$ but we have not yet defined those; we do so in Section~\ref{sec:representable functors}. First we briefly discuss monomorphisms and epimorphisms in general (Definition~\ref{def:mono, epi}) and then in ${ğ“’}\set$ (Proposition~\ref{prop:epi mono in c-set}). 
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{definitionENG}[Monomorphism, Epimorphism]\label{def:mono, epi}\index{epimorphism}\index{monomorphism}
Let ${ğ“¢}$ be a category and let $f\colon X{â†’} Y$ be a morphism. We say that $f$ is a {\em monomorphism} if it has the following property. For all objects $A\in\Ob({ğ“¢})$ and morphisms $g,g'\colon A{â†’} X$ in ${ğ“¢},$ 
$$
\xymatrix{A\ar@/^1pc/[r]^g\ar@/_1pc/[r]_{g'}&X\ar[r]^f&Y}
$$
if $f\circ g=f\circ g'$ then $g=g'.$

We say that $f\colon X{â†’} Y$ is an {\em epimorphism} if it has the following property. For all objects $B\in\Ob({ğ“¢})$ and morphisms $h,h'\colon Y{â†’} B$ in ${ğ“¢},$
$$
\xymatrix{X\ar[r]^f&Y\ar@/^1pc/[r]^h\ar@/_1pc/[r]_{h'}&B}
$$
if $h\circ f=h'\circ f$ then $h=h'.$
\end{definitionENG}

\begin{definitionRUS}[Monomorphism, Epimorphism]\label{def:mono, epi}\index{epimorphism}\index{monomorphism}
\end{definitionRUS}

\begin{blockENG}
In the category of sets, monomorphisms are the same as injections and epimorphisms are the same as surjections (see Proposition~\ref{prop:inj and surj}). The same is true in ${ğ“’}\set$: one can check â€œtable by tableâ€ that a morphism of instances is mono or epi.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{propositionENG}\label{prop:epi mono in c-set}
Let ${ğ“’}$ be a category and let $X,Y\colon{ğ“’}{â†’}\Set$ be objects in ${ğ“’}\set$ and let $f\colon X{â†’} Y$ be a morphism in ${ğ“’}\set.$ Then $f$ is a monomorphism (respectively an epimorphism) if and only if, for every object $c\in\Ob({ğ“’}),$ the function $f(c)\colon X(c){â†’} Y(c)$ is injective (respectively surjective). 
\end{propositionENG}

\begin{propositionRUS}\label{prop:epi mono in c-set}
\end{propositionRUS}

\begin{proofENG}[Sketch of proof]
We first show that if $f$ is mono (respectively epi) then so is $f(c)$ for all $c\in\Ob({ğ“’}).$ Considering $c$ as a functor $c\colon\underline{1}{â†’}{ğ“’},$ this result follows from the fact that ${Î”}_c$ preserves limits and colimits, hence monos and epis. 

We now check that if $f(c)$ is mono for all $c\in\Ob({ğ“’})$ then $f$ is mono. Suppose that $g,g'\colon A{â†’} X$ are morphisms in ${ğ“’}\set$ such that $f\circ g=f\circ g'.$ Then for every $c$ we have $f\circ g(c)=f\circ g'(c)$ which implies by hypothesis that $g(c)=g'(c).$ But the morphisms in ${ğ“’}\set$ are natural transformations, and if two natural transformations $g,g'$ have the same components then they are the same. 

A similar argument works to show the analogous result for epimorphisms.
\end{proofENG}

\begin{proofRUS}[Sketch of proof]
\end{proofRUS}

%% Subsubsection %%

\subsubsection{\caseENGRUS{Representable functors}{ / }{ĞŸÑ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ‚Ğ¾Ñ€Ñ‹}}\label{sec:representable functors}

\begin{blockENG}
Given a category ${ğ“’},$ there are certain functors ${ğ“’}{â†’}\Set$ that come with the package, one for every object in ${ğ“’}.$ So if ${ğ“’}$ is a database schema, then for every table $c\in\Ob({ğ“’})$ there is a certain database instance associated to it. These instances, i.e. set-valued functors, are called representable functors, and they'll be defined in Definition~\ref{def:representable functor}. The idea is that if a database schema represents a conceptual layout of types (e.g. as an olog), then each type $T$ has an instance associated to it, standing for â€œthe generic thing of type $T$ with all its generic attributesâ€.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{definitionENG}\label{def:representable functor}\index{functor!representable}\index{representable functor}
Let ${ğ“’}$ be a category and let $c\in\Ob({ğ“’})$ be an object. The functor $\Hom_{ğ“’}(c,-)\colon{ğ“’}{â†’}\Set,$ sending $d\in\Ob({ğ“’})$ to the set $\Hom_{ğ“’}(c,d)$ and acting similarly on morphisms $d{â†’} d',$ is said to be {\em represented by $c$}. If a functor $F\colon{ğ“’}{â†’}\Set$ is isomorphic to $\Hom_{ğ“’}(c,-),$ we say that $F$ is {\em a representable functor}. We sometimes write $Y_c{\coloneqq}\Hom_{ğ“’}(c,-)$ for short.
\end{definitionENG}

\begin{definitionRUS}\label{def:representable functor}\index{functor!representable}\index{representable functor}
\end{definitionRUS}

\begin{exampleENG}
Given a category ${ğ“’}$ and an object $c\in\Ob({ğ“’}),$ we get a representable functor. If we think of ${ğ“’}$ as a database schema and $c$ as a table, then what does the representable functor $Y_c\colon{ğ“’}{â†’}\Set$ look like in terms of databases? It turns out that the following procedure will generate it. 

Begin by writing a new row, say â€œ${â˜º}$â€, in the ID column of table $c.$ For each foreign key column $f\colon c{â†’} c',$ add a row in the ID column of table $c'$ called $â€œf({â˜º})â€$ and record that result (i.e. â€œ$f({â˜º})$â€) in the $f$ column of table $c.$ Repeat as follows: for each table $d,$ identify all rows $r$ that have blank cell in column $g\colon d{â†’} e.$ Add a new row called $â€œg(r)â€$ to table $e$ and record that result in the $(r,g)$ cell of table $d.$

Here is a concrete example. Let ${ğ“’}$ be the following schema: 
$$\xymatrix{\LMO{A}\ar[r]^f&\LMO{B}\ar@<.5ex>[r]^{g_1}\ar@<-.5ex>[r]_{g_2}\ar[d]_h&\LMO{C}\ar[r]^i&\LMO{D}\\&\LMO{E}}$$
Then $Y_B\colon{ğ“’}{â†’}\Set$ is the following instance
\begin{center}
\begin{tabular}{| l || l |}\bhline
\multicolumn{2}{|c|}{A}\\\bhline
{\bf ID}&{\bf $f$}\\\bbhline
\end{tabular}
\hsp
\begin{tabular}{| l || l | l | l |}\bhline
\multicolumn{4}{|c|}{B}\\\bhline
{\bf ID}&{\bf $g_1$}&{\bf $g_2$}&{\bf $h$}\\\bbhline
${â˜º}$&$g_1({â˜º})$&$g_2({â˜º})$&$h({â˜º})$\\\bhline
\end{tabular}
\hsp
\begin{tabular}{| l || l |}\bhline
\multicolumn{2}{|c|}{C}\\\bhline
{\bf ID}&{\bf $i$}\\\bbhline
$g_1({â˜º})$&$i(g_1({â˜º}))$\\\hline
$g_2({â˜º})$&$i(g_2({â˜º}))$\\\bhline
\end{tabular}
\end{center}
\begin{center}
\begin{tabular}{| l ||}\bhline
\multicolumn{1}{| c |}{D}\\\bhline
{\bf ID}\\\bbhline
$i(g_1({â˜º}))$\\\hline
$i(g_2({â˜º}))$\\\bhline
\end{tabular}
\hsp
\begin{tabular}{| l ||}\bhline
\multicolumn{1}{| c |}{E}\\\bhline
{\bf ID}\\\bbhline
$h({â˜º})$\\\bhline
\end{tabular}
\end{center}

We began with a single element in table $B$ and followed the arrows, putting new entries wherever they were required. One might call this the {\em schematically implied reference spread} or {\em SIRS}\index{schematically implied reference spread} of the element ${â˜º}$ in table $B.$ Notice that the table at $A$ is empty, because there are no morphisms $B{â†’} A.$
\end{exampleENG}

\begin{exampleRUS}
\end{exampleRUS}

\begin{blockENG}
Representable functors $Y_c$ yield databases states that are as free as possible, subject to having the initial row ${â˜º}$ in table $c.$ We have seen things like this before (by the name of Skolem variables)\index{Skolem} when studying the left pushforward ${Î£}.$ Indeed, if $c\in\Ob({ğ“’})$ is an object, we can consider it as a functor $c\colon\underline{1}{â†’}{ğ“’}.$ A database instance on $\underline{1}$ is the same thing as a set $X.$ The left pushforward ${Î£}_c(X)$ has the same kinds of Skolem variables. If $X=\{{â˜º}\}$ is a one element set, then we get the representable functor ${Î£}_c({\{â˜º\}})\iso Y_c.$
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{exerciseENG}\label{exc:representables on graph}
Consider the schema for graphs, 
$$\GrIn{\coloneqq}\fbox{\parbox{1in}{\GrInSchema}}$$
\sexc Write down the representable functor $Y_{Ar}\colon\GrIn{â†’}\Set$ as two tables.
\item Write down the representable functor $Y_{V\!e}$ as two tables.
\endsexc
\end{exerciseENG}

\begin{exerciseRUS}\label{exc:representables on graph}
\end{exerciseRUS}

\begin{exerciseENG}
Consider the loop schema $$\Loop{\coloneqq}\LoopSchema.$$ What is the representable functor $Y_s\colon\Loop{â†’}\Set?$
\end{exerciseENG}

\begin{exerciseRUS}
\end{exerciseRUS}

\begin{blockENG}
Let $B$ be a box in an olog, say \fakebox{a person}, and recall that an aspect of $B$ is an outgoing arrow, such as $\fakebox{a person}\To{\tn{has as height in inches}}\fakebox{an integer}.$ The following slogan explains representable functors in those terms.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{sloganENG}
The functor represented by \fakebox{a person} simply leaves a placeholder, like ${âŸ¨}$person's name here${âŸ©}$ or ${âŸ¨}$person's height here${âŸ©},$ for every aspect of \fakebox{a person}. 

In general, there is a representable functor for every type in an olog. The representable functor for type $T$ simply encapsulates the most generic or abstract example of type $T,$ by leaving a placeholder for each of its attributes.
\end{sloganENG}

\begin{sloganRUS}
\end{sloganRUS}

%% Subsubsection %%

\subsubsection{\caseENGRUS{Yoneda's lemma}{ / }{Ğ›ĞµĞ¼Ğ¼Ğ° Ğ™Ğ¾Ğ½ĞµĞ´Ñ‹}}\label{sec:yoneda}

\begin{blockENG}
One of the most powerful tools in category theory is Yoneda's lemma. It is often considered by new students to be quite abstract, but grounding it in databases may help.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{blockENG}
The idea is this. Suppose that $I\colon{ğ“’}{â†’}\Set$ is a database instance, and let $c\in\Ob({ğ“’})$ be an object. Because $I$ is a functor, we know that for every row $r\in I(c)$ in table $c$ a value has been recorded in the $f$-column, where $f\colon c{â†’} c'$ is any outgoing arrow. The value in the $(r,f)$-cell refers to some row in table $c'.$ What we're saying is that each row in table $c$ induces SIRS throughout the database. They may not be â€œSkolemâ€, or in any sense â€œfreely generatedâ€, but they are there nonetheless. The point is that to each row in $c$ there is a unique mapping $Y_c{â†’} I.$ 
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{lemmaENG}[Yoneda's lemma, part 1.]\index{Yoneda's lemma}\label{lemma:Yoneda}
Let ${ğ“’}$ be a category, $c\in\Ob({ğ“’})$ an object, and $I\colon{ğ“’}{â†’}\Set$ a set-valued functor. There is a natural bijection $$\Hom_{{ğ“’}\set}(Y_c,I)\Too{\iso}I(c).$$
\end{lemmaENG}

\begin{lemmaRUS}[Yoneda's lemma, part 1.]\index{Yoneda's lemma}\label{lemma:Yoneda}
\end{lemmaRUS}

\begin{proofENG}
See \cite{Mac}.
\end{proofENG}

\begin{proofRUS}
\end{proofRUS}

\begin{exampleENG}\label{ex:yoneda}
Consider the category ${ğ“’}$ drawn below:
$$
{ğ“’}{\coloneqq}\parbox{2.1in}{\fbox{\parbox{2.1in}{\begin{center}\small mother\;$\circ$\;firstChild\;=\;$\id_{\tn{Mother}}$\normalsize\end{center}$$\xymatrix{\LTO{Child}\ar[rr]^{\tn{mother}}&&\LTO{Mother}\ar@/^1pc/[ll]^{\tn{firstChild}}}$$}}}
$$
There are two representable functors, $Y_{\tt Child}$ and $Y_{\tt Mother}.$ The latter, when written as a database instance, will consist of a single row in each table. The former, $Y_{\tt Child}\colon{ğ“’}{â†’}\Set$ is shown here:
\begin{center}
\begin{tabular}{| l || l |}\bhline
\multicolumn{2}{|c|}{Child}\\\bhline
{\bf ID}&{\bf mother}\\\hline
${â˜º}$&mother(${â˜º}$)\\\hline
firstChild(mother(${â˜º}$))&mother(${â˜º}$)\\\bbhline
\end{tabular}
\hsp
\begin{tabular}{| l || l |}\bhline
\multicolumn{2}{|c|}{Mother}\\\bhline
{\bf ID}&{\bf firstChild}\\\bbhline
mother(${â˜º}$)&firstChild(mother(${â˜º}$))\\\bhline
\end{tabular}
\end{center}
The representable functor $Y_{\tt Child}$ is the freest instance possible, starting with one element in the Child table and satisfying the constraints. 

Here is another instance $I\colon{ğ“’}{â†’}\Set$:
\begin{center}
\begin{tabular}{| l || l |}\bhline
\multicolumn{2}{|c|}{\tt Child}\\\bhline
{\bf ID}&{\bf mother}\\\hline
Amy&Ms. Adams\\\hline
Bob&Ms. Adams\\\hline
Carl&Ms. Jones\\\hline
Deb&Ms. Smith\\\bhline
\end{tabular}
\hsp
\begin{tabular}{| l || l |}\bhline
\multicolumn{2}{|c|}{\tt Mother}\\\bhline
{\bf ID}&{\bf firstChild}\\\bbhline
Ms. Adams&Bob\\\hline
Ms. Jones&Carl\\\hline
Ms. Smith&Deb\\\bhline
\end{tabular}
\end{center}
\end{exampleENG}

\begin{exampleRUS}\label{ex:yoneda}
\end{exampleRUS}

\begin{blockENG}
Yoneda's lemma (\ref{lemma:Yoneda}) is about the set of natural transformations $Y_{\tt Child}{â†’} I.$ Recall from Definition~\ref{def:natural transformation} that a search for natural transformations can get a bit tedious. Yoneda's lemma makes the calculation quite trivial. In our case there are exactly four such natural transformations, and they are completely determined by where ${â˜º}$ goes. In some sense the symbol ${â˜º}$ {\em represents} child-ness in our database. 
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{exerciseENG}
Consider the schema ${ğ“’}$ and instance $I\colon{ğ“’}{â†’}\Set$ from Example~\ref{ex:yoneda}. Let $Y_{\tt Child}$ be the representable functor as above. 
\sexc Let $\alpha\colon Y_{\tt Child}{â†’} I$ be the natural transformation sending ${â˜º}$ to Amy. What is $\alpha_{\tn{Child}}(\tn{firstChild(mother}({â˜º})))?$
\footnote{There is a lot of clutter, perhaps. Note that â€œfirstChild(mother(${â˜º}$))â€ is a row in the {\tt Child} table. Assuming that the math follows the meaning, if ${â˜º}$ points to Amy, where should firstChild(Mother(${â˜º}$)) point?}
\item Let $\alpha\colon Y_{\tt Child}{â†’} I$ be the natural transformation sending ${â˜º}$ to Bob. What is $\alpha_{\tt Child}(\tn{firstChild(mother}({â˜º})))?$
\item Let $\alpha\colon Y_{\tt Child}{â†’} I$ be the natural transformation sending ${â˜º}$ to Carl. What is $\alpha_{\tt Child}(\tn{firstChild(mother}({â˜º})))?$
\item Let $\alpha\colon Y_{\tt Child}{â†’} I$ be the natural transformation sending ${â˜º}$ to Deb. What is $\alpha_{\tt Child}(\tn{firstChild(mother}({â˜º})))?$
\item Let $\alpha\colon Y_{\tt Child}{â†’} I$ be the natural transformation sending ${â˜º}$ to Amy. What is $\alpha_{\tt Mother}(\tn{mother}({â˜º}))?$
\endsexc
\end{exerciseENG}

\begin{exerciseRUS}
\end{exerciseRUS}

\begin{blockENG}
We saw in Section~\ref{sec:representable functors} that a representable functor is a mathematically-generated database instance for an abstract thing of type $T.$ It creates placeholders for every attribute that things of type $T$ are supposed to have.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{sloganENG}
Yoneda's lemma says the following. Specifying an actual thing of type $T$ is the same as filling in all placeholders found in the generic thing of type $T.$
\end{sloganENG}

\begin{sloganRUS}
\end{sloganRUS}

\begin{blockENG}
Yoneda's lemma is considered by many category theory lovers to be the most important tool in the subject. While its power is probably unclear to students whose sole background in category theory comes from this book, Yoneda's lemma is indeed extremely useful for reasoning. It allows us to move the notion of functor application into the realm of morphisms between functors (i.e. morphisms in ${ğ“’}\set,$ which are natural transformations). This keeps everything in one place â€” it's all in the morphisms â€” and thus more interoperable.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{exampleENG}\label{ex:yoneda for cyclic monoid}
In Example~\ref{ex:cyclic monoid (7,4)}, we discussed the cyclic monoid ${ğ“œ}$ generated by the symbol $Q$ and subject to the relation $Q^7=Q^4.$ We drew a picture like this: 
\begin{align}\label{dia:grothendieck yoneda (4,7)}
\xymatrix@=15pt{
\LMO{Q^0}\ar[rr]&&\LMO{Q^1}\ar[rr]&&\LMO{Q^2}\ar[rr]&&\LMO{Q^3}\ar[rr]&&\LMO{Q^4}\ar[dr]\\
&&&&&&&\LMO{Q^6}\ar[ur]&&\LMO{Q^5}\ar[ll]
}
\end{align}
We are finally ready to give the mathematical foundation for this picture. Since ${ğ“œ}$ is a category with one object, ${â–´},$ there is a unique representable functor (up to isomorphism) $Y{\coloneqq}Y_{â–´}\colon{ğ“œ}{â†’}\Set.$ A functor ${ğ“œ}{â†’}\Set$ can be thought of as a set with an ${ğ“œ}$-action, as discussed in Section~\ref{sec:monoids as cats}. Here the required set is 
$$Y({â–´})=\Hom_{ğ“œ}({â–´},{â–´})\iso\{Q^0,Q^1,Q^2,Q^3,Q^4,Q^5,Q^6\}$$ 
and the action is pretty straightforward (it is called the {\em principal action}). We might say that (\ref{dia:grothendieck yoneda (4,7)}) is a picture of this principal action of ${ğ“œ}.$ 

However, we can go one step further. Given a functor $Y\colon{ğ“œ}{â†’}\Set,$ we can take its category of elements, $\int_{ğ“œ} Y$ as in Section~\ref{sec:grothendieck construction}. The category $\int_{ğ“œ} Y$ has objects $Y({â–´})\in\Ob(\Set),$ i.e. the set of dots in (\ref{dia:grothendieck yoneda (4,7)}), and it has a unique morphism $Q^i{â†’} Q^j$ for every path of length $\leq 6$ from $Q^i$ to $Q^j$ in that picture.
\end{exampleENG}

\begin{exampleRUS}\label{ex:yoneda for cyclic monoid}
\end{exampleRUS}

\begin{exerciseENG}
Let $c\in\Ob({ğ“’})$ be an object and let $I\in\Ob({ğ“’}\set)$ be another object. Consider $c$ also as a functor $c\colon\underline{1}{â†’}{ğ“’}$ and recall the pullback functor ${Î”}_c\colon{ğ“’}\set{â†’}\Set$ and its left adjoint ${Î£}_c\colon\Set{â†’}{ğ“’}\set$ from Section~\ref{sec:data migration}.
\sexc What is the set ${Î”}_c(I)?$
\item What is $\Hom_\Set({\{â˜º\}},{Î”}_c(I))?$
\item What is $\Hom_{{ğ“’}\set}({Î£}_c({\{â˜º\}}),I)?$
\item How does ${Î£}_c({\{â˜º\}})$ compare to $Y_c,$ the functor represented by $c,$ as objects in ${ğ“’}\set?$
\endsexc
\end{exerciseENG}

\begin{exerciseRUS}
\end{exerciseRUS}

\begin{lemmaENG}[Yoneda's lemma, part 2]
Let ${ğ“’}$ be a category. The assignment $c\mapsto Y_c$ from Lemma~\ref{lemma:Yoneda} extends to a functor $Y\colon{ğ“’}\op{â†’}{ğ“’}\set,$ and this functor is fully faithful. 

In particular, if $c,c'\in\Ob({ğ“’})$ are objects and there is an isomorphism $Y_c\iso Y_{c'}$ in ${ğ“’}\set,$ then there is an isomorphism $c\iso c'$ in ${ğ“’}.$
\end{lemmaENG}

\begin{lemmaRUS}[Yoneda's lemma, part 2]
\end{lemmaRUS}

\begin{proofENG}
See \cite{Mac}.
\end{proofENG}

\begin{proofRUS}
\end{proofRUS}

\begin{exerciseENG}
The distributive law for addition of natural numbers says $(a+b)\times c=a\times c+b\times c.$ Below we will give a proof of the distributive law, using category-theoretic reasoning. Annotate anything in {\color{red}red} ink  with a justification for why it is true.
\begin{propositionENG}
For any natural numbers $a,b,c\in{â„•},$ the distributive law 
$$(a+b)c=ac+bc$$ 
holds.
\end{propositionENG}
\begin{proofENG}[Sketch of proof. To finish, justify {\color{red}red stuff}]
~\\
Let $A,B,C$ be finite sets and let $X$ be another finite set.
\begin{align*}
\Hom_\Set((A+B)\times C,X)
&{\color{red}\iso}\Hom_\Set(A+B,X^C)\\
&{\color{red}\iso}\Hom_\Set(A,X^C)\times\Hom_\Set(B,X^C)\\
&{\color{red}\iso}\Hom_\Set(A\times C,X)\times\Hom_\Set(B\times C,X)\\
&{\color{red}\iso}\Hom_\Set((A\times C)+(B\times C),X).
\end{align*}
By {\color{red} the appropriate application} of Yoneda's lemma, we see that there is an isomorphism
$$(A+B)\times C\iso(A\times C)+(B\times C)$$
in $\Fin.$ The result about natural numbers {\color{red}follows}.
\end{proofENG}
\end{exerciseENG}

\begin{exerciseRUS}
\begin{propositionRUS}
\end{propositionRUS}
\begin{proofRUS}[Sketch of proof. To finish, justify {\color{red}red stuff}]
\end{proofRUS}
\end{exerciseRUS}

%% Subsubsection %%

\subsubsection{\caseENGRUS{The subobject classifier}{ / }{ĞšĞ»Ğ°ÑÑĞ¸Ñ„Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€ Ğ¿Ğ¾Ğ´Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ²}: \texorpdfstring{$\Omega\in\Ob({ğ“’}\set)$}{Î©âˆˆOb(C-Set)}}

\begin{blockENG}
If ${ğ“’}$ is a category then the functor category ${ğ“’}\set$ is a very nice kind of category, called a {\em topos}.\index{topos} Note that when ${ğ“’}=\underline{1}$ is the terminal category, then we have an isomorphism ${ğ“’}\set\iso\Set,$ so the category of sets is a special case of a topos. What is so interesting about toposes (or topoi) is that they so nicely generalize many properties of $\Set.$ In this short section we investigate only one such property, namely that ${ğ“’}\set$ has a subobject classifier, denoted $\Omega\in\Ob({ğ“’}\set).$ In the case ${ğ“’}=\underline{1},$ we saw back in Section~\ref{def:subobject classifier} that the subobject classifier is $\{True,False\}\in\Ob(\Set).$ 
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{blockENG}
As usual, we consider the matter of subobject classifiers by grounding the discussion in terms of databases.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{definitionENG}
Let ${ğ“’}$ be a category, let ${ğ“’}\set$ denote its category of instances, and let $1\in\Ob({ğ“’}\set)$ denote the terminal object. A {\em subobject classifier for ${ğ“’}\set$} is an object $\Omega_{ğ“’}\in\Ob({ğ“’}\set)$ and a morphism $t\colon 1{â†’}\Omega_{ğ“’}$ with the following property. For any monomorphism $f\colon X{â†’} Y$ in ${ğ“’}\set,$ there exists a unique morphism $char(f)\colon Y{â†’}\Omega_{ğ“’}$ such that the following diagram is a pullback in ${ğ“’}\set$:
$$
\xymatrix@=25pt{X\ar[r]^{!}\ar[d]_f\ullimit&1\ar[d]^t\\Y\ar[r]_{char(f)}&\Omega_{ğ“’}
}
$$
\end{definitionENG}

\begin{definitionRUS}
\end{definitionRUS}

\begin{blockENG}
In terms of databases, what this means is that for every schema ${ğ“’}$ there is some special instance $\Omega_{ğ“’}\in\Ob({ğ“’}\set)$ that somehow classifies sub-instances.\index{subobject classifier!in ${ğ“’}\set$} When our schema is the terminal category, ${ğ“’}=\underline{1},$ instances are sets and we saw in Definition~\ref{def:subobject classifier} that the subobject classifier is $\Omega_{\underline{1}}=\{True, False\}.$ One might think that the subobject classifier for ${ğ“’}\set$ should just consist of a two-element set table-by-table, i.e. that for every $c\in\Ob({ğ“’})$ we should have $\Omega_{{ğ“’}}=^?\{True,False\},$ but this is not correct. 
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{blockENG}
In fact, for any object $c\in\Ob({ğ“’}),$ it is easy to say what $\Omega_{ğ“’}(c)$ should be. We know by Yoneda's lemma (Lemma~\ref{lemma:Yoneda}) that $\Omega_{ğ“’}(c)=\Hom_{{ğ“’}\set}(Y_c,\Omega_{ğ“’}),$ where $Y_c$ is the functor represented by $c.$ There is a bijection between $\Hom_{{ğ“’}\set}(Y_c,\Omega_{ğ“’})$ and the set of sub-instances of $Y_c.$ Each morphism $f\colon c{â†’} d$ in ${ğ“’}$ induces a morphism $Y_f\colon Y_d{â†’} Y_c,$ and the map $\Omega_{ğ“’}(f)\colon\Omega_{ğ“’}(c){â†’}\Omega_{ğ“’}(d)$ sends a sub-instance $A\subseteq Y_c$ to the pullback 
$$
\xymatrix{Y_f^{-1}(A)\ar[r]\ar[d]\ullimit&A\ar[d]\\Y_d\ar[r]_{Y_f}&Y_c}
$$
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{blockENG}
But this is all very abstract. We now give an example of a subobject classifier.  
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{exampleENG}
Consider the category ${ğ“’}\iso[3]$ depicted below
$${ğ“’}{\coloneqq}\parbox{3in}{\fbox{
\xymatrix{&&&\ar@{}[d]|(.4){\checkmark}&&&\\
\LTO{0}\ar[rr]^{\tn{after\_1}}\ar@/_1.5pc/[rrrr]_{\tn{after\_2}}\ar@/^3pc/[rrrrrr]^{\tn{after\_3}}&&\LTO{1}\ar[rr]^{\tn{after\_1}}\ar@/_1.5pc/[rrrr]_{\tn{after\_2}}&&\LTO{2}\ar[rr]^{\tn{after\_1}}&&\LTO{3}\\
&&&\ar@{}[ull]|(.8){\checkmark}\ar@{}[urr]|(.8){\checkmark}&&
}}}
$$
To write down $\Omega_{ğ“’}$ we need to understand the representable functors $Y_c\in\Ob({ğ“’}\set),$ for $c={\tt 0},{\tt 1},{\tt 2},{\tt 3},$ as well as their subobjects. Here is $Y_{\tt 0}$ as an instance:

\begin{center}\small
\begin{tabular}{| l || l | l | l |}
\bhline
\multicolumn{4}{|c|}{$Y_{\tt 0}({\tt 0})$}\\\bhline
{\bf ID}&{\bf after\_1}&{\bf after\_2}&{\bf after\_3}\\\bbhline
${â˜º}$&after\_1(${â˜º}$)&after\_2(${â˜º}$)&after\_3(${â˜º}$)\\\bhline
\end{tabular}
\hsp
\begin{tabular}{| l || l | l |}
\bhline
\multicolumn{3}{|c|}{$Y_{\tt 0}({\tt 1})$}\\\bhline
{\bf ID}&{\bf after\_1}&{\bf after\_2}\\\bbhline
after\_1$({â˜º})$&after\_2$({â˜º})$&after\_3$({â˜º})$\\\bhline
\end{tabular}\\\vspace{.2in}
\begin{tabular}{| l || l |}
\bhline
\multicolumn{2}{|c|}{$Y_{\tt 0}({\tt 2})$}\\\bhline
{\bf ID}&{\bf after\_1}\\\bbhline
after\_2$({â˜º})$&after\_3$({â˜º})$\\\bhline
\end{tabular}
\hsp
\begin{tabular}{| l ||}
\bhline
\multicolumn{1}{|c|}{$Y_{\tt 0}({\tt 3})$}\\\bhline
{\bf ID}\\\bbhline
after\_3$({â˜º})$\\\bhline
\end{tabular}
\end{center}

What are the sub-instances of this? There is the empty sub-instance $\emptyset\subseteq Y_{\tt 0}$ and the identity sub-instance $Y_{\tt 0}\subseteq Y_{\tt 0}.$ But there are three more as well. Note that if we want to keep the ${â˜º}$ row of table {\tt 0} then we have to keep everything. But if we throw away the ${â˜º}$ row of table {\tt 0} we can still keep the rest and get a sub-instance. If we want to keep the after\_1$({â˜º})$ row of table {\tt 1} then we have to keep its images in tables {\tt 2} and {\tt 3}. But we could throw away both the ${â˜º}$ row of table {\tt 0} and the after\_1$({â˜º})$ row of table {\tt 1} and still keep the rest. And so on. In other words, the subobjects of $Y_{\tt 0}$ are in bijection with the set $\Omega_{ğ“’}({\tt 0}){\coloneqq}\{\tn{{\it yes}, {\it in 1}, {\it in 2}, {\it in 3}, {\it never}}\}.$ 

The same analysis holds for the other tables of $\Omega_{ğ“’}.$ It looks like this:
\begin{center}
\begin{tabular}{| l || l | l | l |}
\bhline
\multicolumn{4}{|c|}{$\Omega_{ğ“’}({\tt 0})$}\\\bhline
{\bf ID}&{\bf after\_1}&{\bf after\_2}&{\bf after\_3}\\\bbhline
{\it yes}&{\it yes}&{\it yes}&{\it yes}\\\hline
{\it in 1}&{\it yes}&{\it yes}&{\it yes}\\\hline
{\it in 2}&{\it in 1}&{\it yes}&{\it yes}\\\hline
{\it in 3}&{\it in 2}&{\it in 1}&{\it yes}\\\hline
{\it never}&{\it never}&{\it never}&{\it never}\\\bhline
\end{tabular}
\hsp
\begin{tabular}{| l || l | l |}
\bhline
\multicolumn{3}{|c|}{$\Omega_{ğ“’}({\tt 1})$}\\\bhline
{\bf ID}&{\bf after\_1}&{\bf after\_2}\\\bbhline
{\it yes}&{\it yes}&{\it yes}\\\hline
{\it in 1}&{\it yes}&{\it yes}\\\hline
{\it in 2}&{\it in 1}&{\it yes}\\\hline
{\it never}&{\it never}&{\it never}\\\bhline
\end{tabular}\\\vspace{.2in}
\begin{tabular}{| l || l |}
\bhline
\multicolumn{2}{|c|}{$\Omega_{ğ“’}({\tt 2})$}\\\bhline
{\bf ID}&{\bf after\_1}\\\bbhline
{\it yes}&{\it yes}\\\hline
{\it in 1}&{\it yes}\\\hline
{\it never}&{\it never}\\\bhline
\end{tabular}
\hsp
\begin{tabular}{| l ||}
\bhline
\multicolumn{1}{|c|}{$\Omega_{ğ“’}({\tt 3})$}\\\bhline
{\bf ID}\\\bbhline
{\it yes}\\\hline
{\it never}\\\bhline
\end{tabular}

\end{center}
The morphism $1{â†’}\Omega_{ğ“’}$ picks out the {\it yes} row of every table.

Now that we have constructed $\Omega_{ğ“’}\in\Ob({ğ“’}\set),$ we are ready to see it in action. What makes $\Omega_{ğ“’}$ special is that for any instance $X\colon{ğ“’}{â†’}\Set,$ the subinstances if $X$ are in one-to-one correspondence with the morphisms $X{â†’}\Omega_{ğ“’}.$ Consider the following arbitrary instance $X,$ where the blue rows denote a sub-instance $A\subseteq X.$

\begin{align}\label{dia:instance for omega}\scriptsize
\begin{array}{| l || l | l | l |}
\bhline
\multicolumn{4}{|c|}{X({\tt 0})}\\\bhline
{\bf ID}&{\bf after\ 1}&{\bf after\ 2}&{\bf after\ 3}\\\bbhline
a_1&b_1&\color{blue}{c_1}&\color{blue}{d_1}\\\hline
a_2&\color{blue}{b_2}&\color{blue}{c_1}&\color{blue}{d_1}\\\hline
a_3&\color{blue}{b_2}&\color{blue}{c_1}&\color{blue}{d_1}\\\hline
a_4&b_3&c_2&d_2\\\hline
a_5&b_5&c_3&\color{blue}{d_1}\\\bhline
\end{array}
\hspace{.2in}
\begin{array}{| l || l | l |}
\bhline
\multicolumn{3}{|c|}{X({\tt 1})}\\\bhline
{\bf ID}&{\bf after\ 1}&{\bf after\ 2}\\\bbhline
b_1&\color{blue}{c_1}&\color{blue}{d_1}\\\hline
\color{blue}{b_2}&\color{blue}{c_1}&\color{blue}{d_1}\\\hline
b_3&c_2&d_2\\\hline
\color{blue}{b_4}&\color{blue}{c_1}&\color{blue}{d_1}\\\hline
b_5&c_3&\color{blue}{d_1}\\\bhline
\end{array}\hspace{.2in}
\begin{array}{| l || l |}
\bhline
\multicolumn{2}{|c|}{X({\tt 2})}\\\bhline
{\bf ID}&{\bf after\ 1}\\\bbhline
\color{blue}{c_1}&\color{blue}{d_1}\\\hline
c_2&d_2\\\hline
c_3&\color{blue}{d_1}\\\bhline
\end{array}
\hspace{.2in}
\begin{array}{| l ||}
\bhline
\multicolumn{1}{|c|}{X({\tt 3})}\\\bhline
{\bf ID}\\\bbhline
\color{blue}{d_1}\\\hline
d_2\\\bhline
\end{array}
\end{align}

This blue sub-instance $A\subseteq X$ corresponds to a map $char(A)\colon X{â†’}\Omega_{ğ“’}.$ That is for each $c\in\Ob({ğ“’})$ the rows in the $c$-table of $X$ are sent to the rows in the $c$-table of $\Omega_{ğ“’}.$ The way $char(A)$ works is as follows. For each table $i$ and row $x\in X(i),$ find the first column $f$ in which the entry is blue (i.e. $f(x)\in A$), and send $x$ to the corresponding element of $\Omega_{ğ“’}(i).$ For example, $char(A)({\tt 0})$ sends $a_1$ to {\it in 2} and sends $a_4$ to {\it never}, and $char(A)({\tt 2})$ sends $c_1$ to {\it yes} and sends $c_2$ to {\it never}.
\end{exampleENG}

\begin{exampleRUS}
\end{exampleRUS}

\begin{exerciseENG}
\sexc Write out the blue subinstance $A\subseteq X$ shown in (\ref{dia:instance for omega}) as an instance of ${ğ“’},$ i.e. as four tables. 
\item This subinstance $A\subseteq X$ corresponds to a map $\ell{\coloneqq}char(A)\colon X{â†’}\Omega_{ğ“’}.$ For all $c\in\Ob({ğ“’})$ we have a function $\ell(c)\colon X(c){â†’}\Omega_{ğ“’}(c).$ With $c={\tt 1},$ write out $\ell({\tt 1})\colon X({\tt 1}){â†’}\Omega_{ğ“’}({\tt 1}).$
\endsexc
\end{exerciseENG}

\begin{exerciseRUS}
\end{exerciseRUS}

\begin{exerciseENG}
Let $\Loop$ be the loop schema 
$$\Loop=\LoopSchema.$$ 
\sexc What is the subobject classifier $\Omega_\Loop\in\Ob(\Loop\set)?$
\item How does $\Omega_\Loop$ compare to the representable functor $Y_s?$
\endsexc
\end{exerciseENG}

\begin{exerciseRUS}
\end{exerciseRUS}

\begin{exerciseENG}   
Let $\GrIn=\fbox{\GrInSchema}$ be the indexing category for graphs. 
\sexc Write down the subobject classifier $\Omega_\GrIn\in\Ob(\GrIn\set)$ in tabular form, i.e. as two tables.
\item Draw $\Omega_\GrIn$ as a graph.
\item Let $G$ be the graph below and $G'\subseteq G$ the blue part.
$$\xymatrix{
\LMO{\color{blue}{w}}\ar@/^1pc/[r]^f\ar@[blue][r]_{\color{blue}{g}}\ar[d]_h&\LMO{\color{blue}{x}}\\
\LMO{y}\ar@(l,d)[]_j\ar[r]_i&\LMO{\color{blue}{z}}
}
$$
Write down $G\in\Ob(\GrIn\set)$ in tabular form.
\item Write down the components of the natural transformation $char(G')\colon G{â†’}\Omega_\GrIn.$
\endsexc
\end{exerciseENG}

\begin{exerciseRUS}   
\end{exerciseRUS}

%%%% Subsection %%%%

\subsection{\caseENGRUS{Database instances in other categories}{ / }{Ğ­ĞºĞ·ĞµĞ¼Ğ¿Ğ»ÑÑ€Ñ‹ Ğ±Ğ°Ğ· Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ² Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸ÑÑ…}}

%% Subsubsection %%

\subsubsection{\caseENGRUS{Representations of groups}{ / }{ĞŸÑ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ³Ñ€ÑƒĞ¿Ğ¿}}\label{ex:reps of groups}

\begin{blockENG}
The classical mathematical subject of {\em representation theory}\index{representation theory} is the study of $\Fun(G,\Vect)$ where $G$ is a group and $\Vect$ is the category of vector spaces (over say ${â„}$).\index{vector space}\index{a category!$\Vect$} Every such functor $F\colon G{â†’}\Vect$ is called a {\em representation of $G$}. Since $G$ is a category with one object ${â–´},$ $F$ consists of a single vector space $V=F({â–´})$ together with an action of $G$ on it. 
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{blockENG}
We can think of this in terms of databases if we have a presentation of $G$ in terms of generators and relations. The schema corresponding to $G$ has one table and this table has a column for each generator. Giving a representation $F$ is the same as giving an instance on our schema, with some properties that stem from the fact that our target category is $\Vect$ rather than $\Set.$ There are many possibilities for expressing
\footnote{We would use the term â€œrepresentingâ€ or â€œpresentingâ€, but they are both taken in the context of our narrative!}
such data.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{blockENG}
One possibility is if we could somehow draw $V,$ say if $V$ is 1-, 2-, or 3-dimensional. If so, let $P$ be our chosen picture of $V,$ e.g. $P$ is the standard drawing of a Cartesian coordinate plane. Then every column of our table would consist entirely of the picture $P$ instead of a set of rows. Drawing a point in the ID-column picture would result in a point being drawn in each other column's picture, in accordance with the $G$-action. Each column would of course respect addition and scalar multiplication.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{blockENG}
Another possibility is to use the fact that there is a functor $U\colon\Vect{â†’}\Set,$ so our instance $F\colon G{â†’}\Vect$ can be converted to an ordinary instance $U\circ F\colon G{â†’}\Set.$ We would have an ordinary set of rows. This set would generally be infinite, but it would be structured by addition and scalar multiplication. For example, assuming $V$ is finite dimensional, one could find a few rows that generated the rest. 
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{blockENG}
A third possibility is to use monads, which allow the table to have only as many rows as $V$ has dimensions. This is a considerable savings of space. See Section~\ref{sec:monads}.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

%% Subsubsection %%

\subsubsection{\caseENGRUS{Representations of quivers}{ / }{ĞŸÑ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ»Ñ‡Ğ°Ğ½Ğ¾Ğ²}}

\begin{blockENG}
Representation theory also studies representations of quivers. A {\em quiver} is just the free category (see Example~\ref{ex:free category}\index{category!free category}\index{graph!free category on}) on a graph. If $P$ is a graph with free category ${ğ“Ÿ}$ then a representation of the quiver ${ğ“Ÿ}$ is a functor $F\colon{ğ“Ÿ}{â†’}\Vect.$ Such a representation consists of a vector space at every vertex of $P$ and a linear transformation for every arrow. All of the discussion from Section~\ref{ex:reps of groups} works in this setting, except that there is more than one table.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

%% Subsubsection %%

\subsubsection{\caseENGRUS{Other target categories}{ / }{Ğ”Ñ€ÑƒĞ³Ğ¸Ğµ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸ Ğ² ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğµ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ğ¸ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹}}\label{sec:other targets}

\begin{blockENG}
One can imagine the value of using target categories other than $\Set$ or $\Vect$ for databases. 
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{applicationENG}\index{geography}
\href{http://en.wikipedia.org/wiki/Geographic_data}{\text Geographic data} consists of maps of the earth together with various functions on it. For example for any point on the earth one may want to know the average temperature recorded in the past 10 years, or the precise temperature at this moment. Earth can be considered as a topological space, $E.$ Similarly, temperatures on earth reside on a continuum, say the space $T$ of real numbers $[-100,200].$ Thus the temperature record is a function $E{â†’} T.$ 

Other records such as precipitation, population density, elevation, etc. can all be considered as continuous functions from $E$ to some space. Agencies like the US Geological Survey hold databases of such information. By modeling them on functors ${ğ“’}{â†’}\Top,$ they may be able to employ mathematical tools such as persistent homology \cite{WeS} to find interesting invariants of the data.
\end{applicationENG}

\begin{applicationRUS}\index{geography}
\end{applicationRUS}

\begin{applicationENG}
Many other scientific disciplines could use the same kind of tool. For example, in studying the \href{http://en.wikipedia.org/wiki/Strength_of_materials}{\text mechanics of materials}, one may want to consider the material as a topological space $M$ and measure values such as energy as a continuous $M{â†’} E.$ Such observations could be modeled by databases with target category $\Top$ or $\Vect$ rather than $\Set.$
\end{applicationENG}

\begin{applicationRUS}
\end{applicationRUS}

%%%% Subsection %%%%

\subsection{\caseENGRUS{Sheaves}{ / }{ĞŸÑƒÑ‡ĞºĞ¸}}\label{sec:sheaves}

\begin{blockENG}
Let $X$ be a topological space (see Example~\ref{ex:topological space}), such as a sphere. In Section~\ref{sec:other targets} we discussed continuous functions out of $X,$ and their use in science (e.g. recording temperatures on the earth as a continuous map $X{â†’}[-100,200]$). Sheaves allow us to consider the local-global nature of such maps, taking into account reparable discrepancies in data gathering tools. 
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{applicationENG}\label{app:sheaves of temperature}
Suppose that $X$ is the topological space corresponding to the earth; by a {\em region} we mean an open subset $U\subseteq X.$ Suppose that we cover $X$ with 10,000 regions $U_1,U_2,\ldots,U_{10000},$ such that some of the regions overlap in a non-empty subregion (e.g. perhaps $U_5\cap U_9\neq\emptyset).$ For each $i,j$ let $U_{i,j}=U_i\cap U_j.$ 

For each region $U_i\subseteq X$ we have a temperature recording device, which gives a function $T_i\colon U_i{â†’}[-100,200].$ If $U_i\cap U_j\neq\emptyset$ then two different recording devices give us temperature data for the intersection $U_{i,j}.$ Suppose we find that they do not give precisely the same data, but that there is a translation formula between their results. For example, $T_i$ might register $3^\circ$ warmer than $T_j$ registers, throughout the region $U_i\cap U_j.$

A consistent system of translation formulas is called a {\em sheaf}. It does not demand a universal â€œtrueâ€ temperature function, but only a consistent translation system between them. 
\end{applicationENG}

\begin{applicationRUS}\label{app:sheaves of temperature}
\end{applicationRUS}

\begin{blockENG}
The following definitions (Definitions~\ref{def:presheaf},~\ref{def:sheaf}) make the notion of sheaf precise, but we must go slowly (because it will already feel quick to the novice). For every region $U,$ we can record the value of some function (say temperature) throughout $U$; although this record might consist of a mountain of data (a temperature for each point in $U$!), we think of it as one thing. That is, it is one element in the set of value-assignments throughout $U.$ A sheaf holds the set of possible values-assignments-throughout-$U$'s for all the different regions $U,$ as well as how a value-assignment-throughout-$U$ restricts to a value-assignment-throughout-$V$ for any subset $V\subseteq U.$
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{definitionENG}\label{def:presheaf}\index{presheaf}
Let $X$ be a topological space, let $\Op(X)$ denote its partial order of open sets, and let $\Op(X)\op$ be the opposite category. A {\em presheaf on $X$} is a functor ${ğ“}\colon\Op(X)\op{â†’}\Set.$ For every open set $U\subseteq X$ we refer to the set ${ğ“}(U)$ as the {\em set of values-assignments throughout $U$ of ${ğ“}$}. If $V\subseteq U$ is an open subset, it corresponds to an arrow in $\Op(X)$ and applying the functor ${ğ“}$ yields a function called the {\em restriction map from $U$ to $V$} and denoted $\rho_{V,U}\colon{ğ“}(U){â†’}{ğ“}(V).$ Given $a\in{ğ“}(U),$ we may denote $\rho_{V,U}(a)$ by $a|_V$; it is called {\em the restriction of $a$ to $V$}.

The {\em category of presheaves on $X$} is simply $\Op(X)\op\set$; see Definition~\ref{def:mcC-set}.
\end{definitionENG}

\begin{definitionRUS}\label{def:presheaf}\index{presheaf}
\end{definitionRUS}

\begin{exerciseENG}~
\sexc Come up with $4$ overlapping open subsets that cover the square $X{\coloneqq}[0,3]\times[0,3]\subseteq{â„}^2.$ Write down a label for each open set as well as a label for each overlap (2-fold, 3-fold, etc.); you now have labeled $n$ open sets. For each of these open sets, draw a dot with the appropriate label, and then draw an arrow from one dot to another when the first refers to an open subset of the second. This is a preorder; call it $\Op(X).$ Now make up and write down formulas $R_1\colon X{â†’}{â„}$ and $R_2\colon X{â†’}{â„}$ with $R_1\leq R_2,$ expressing a range of temperatures $R_1(p)\leq x\leq R_2(p)$ that an imaginary experiment shows can exist at each point $p$ in the square. 
\item Suppose we now tried to make our presheaf ${ğ“}\colon\Op(X)\op{â†’}\Set$ as follows. For each of your open sets, say $A,$ we could put $${ğ“}(A){\coloneqq}\{f\colon A{â†’}{â„}{\;|\;}R_1(a)\leq f(a)\leq R_2(a)\}.$$ What are the restriction maps? Do you like the name â€œvalue-assignment throughout $A$â€ for elements of ${ğ“}(A)?$ 
\item We can now make another presheaf ${ğ“}'$ given the same experiment. For each of your open sets, say $A,$ we could put $${ğ“}'(A){\coloneqq}\{f\colon A{â†’}{â„}{\;|\;}f\tn{ is continuous, and }R_1(a)\leq f(a)\leq R_2(a)\}.$$ Are you comfortable with the idea that there is a morphism of presheaves ${ğ“}'{â†’}{ğ“}?$
\endsexc
\end{exerciseENG}

\begin{exerciseRUS}~
\end{exerciseRUS}

\begin{blockENG}
Before we define sheaves, we need to clarify the notion of covering. Suppose that $U$ is a region and that $V_1,\ldots,V_n$ are subregions (i.e. for each $1\leq i\leq n$ we have $V_i\subseteq U$). Then we say that the $V_i$ {\em cover} $U$ if every point in $U$ is in $V_i$ for some $i.$ Another way to say this is that the natural function $\sqcup_iV_i{â†’} U$ is surjective.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{exampleENG}\label{ex:open cover}\index{open cover}
Let $X={â„}$ be the space of real numbers, and define the following open subsets: $U=(5,10), V_1=(5,7), V_2=(6,9), V_3=(7,10).$
\footnote{We use parentheses to denote open intervals of real numbers. For example $(6,9)$ denotes the set $\{x\in{â„}{\;|\;}6<x<9\}.$} 
Then $V_1, V_2, V_3$ is a cover of $U.$ It has overlaps $V_{12}=V_1\cap V_2=(6,7),$ $V_{13}=V_1\cap V_3=\emptyset,$ $V_{23}=V_2\cap V_3=(7,9).$ 

Given a presheaf ${ğ“}\colon\Op(X)\op{â†’}\Set,$ we have sets and functions as in the following (incomplete) diagram
$$
\xymatrix@=15pt{
&&{ğ“}(V_1)\ar[drr]\\
&&&&{ğ“}(V_1\cap V_2)\\
{ğ“}(U)\ar[uurr]\ar[rr]\ar[ddrr]&&{ğ“}(V_2)\ar[urr]\ar[drr]\\
&&&&{ğ“}(V_2\cap V_3)\\
&&{ğ“}(V_3)\ar[urr]
}
$$
\end{exampleENG}

\begin{exampleRUS}\label{ex:open cover}\index{open cover}
\end{exampleRUS}

\begin{blockENG}
A presheaf ${ğ“}$ on $X$ tells us what value-assignments throughout $U$ can exist for each $U.$ Suppose we have a value-assignment $a\in{ğ“}(U)$ throughout $U$ and another value-assignment $a'\in{ğ“}(U')$ throughout $U',$ and suppose that they agree as value-assignments throughout $U\cap U',$ i.e. $a|_{U\cap U'}=a'|_{U\cap U'}.$ In this case we should have a unique value-assignment $b\in{ğ“}(U\cup U')$ throughout $U\cup U'$ that agrees on the $U$-part with $a$ and agrees on the $U'$-part with $a'$; i.e. $b|_U=a$ and $b|_{U'}=a'.$ This is the sheaf condition. 
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{definitionENG}\label{def:sheaf}\index{sheaves}
Let $X$ be a topological space, let $\Op(X)$ be its partial order of open sets, and let ${ğ“}\colon\Op(X)\op{â†’}\Set$ be a presheaf. Given an open set $U\subseteq X$ and a cover $V_1,\ldots, V_n$ of $U,$ the following condition is called the {\em sheaf condition}\index{sheaf!condition} for that cover. 
\begin{description}
\item [Sheaf condition] Given a sequence $a_1,\ldots,a_n$ where each is a value-assignment $a_i\in{ğ“}(V_i)$ throughout $V_i,$ suppose that for all $i,j$ we have $a_i|_{V_i\cap V_j}=a_j|_{V_i\cap V_j}$; then there is a unique value-assignment $b\in{ğ“}(U)$ such that $b|_{V_i}=a_i.$
\end{description}
The presheaf ${ğ“}$ is called a {\em sheaf} if it satisfies the sheaf condition for every cover.
\end{definitionENG}

\begin{definitionRUS}\label{def:sheaf}
\end{definitionRUS}

\begin{exampleENG}
Let $X={â„}$ and let $U, V_1,V_2,V_3$ be the open cover given in Example~\ref{ex:open cover}. Given a measurement taken throughout $V_1,$ a measurement taken throughout $V_2,$ and a measurement taken throughout $V_3,$ we have elements $a_1\in{ğ“}(V_1), a_2\in{ğ“}(V_2),$ and $a_3\in{ğ“}(V_3).$ If they are in agreement on the overlap intervals, we can {\em glue} \index{sheaf!glueing} them to give a measurement throughout $U.$
\end{exampleENG}

\begin{exampleRUS}
\end{exampleRUS}

\begin{remarkENG}
In Application~\ref{app:sheaves of temperature}, we said that sheaves would help us patch together information from different sources. Even if different temperature-recording devices $T_i$ and $T_j$ registered different temperatures on an overlapping region $U_i\cap U_j,$ we said they could be patched together if there was a consistent translation system between their results. What is actually needed is a set of isomorphisms 
$$p_{i,j}\colon T_i|_{U_{i,j}}\To{\iso} T_j|_{U_{i,j}}$$ 
that translate between them, and that these $p_{i,j}$'s act in concert with one another. This (when precisely defined,) is called \href{http://en.wikipedia.org/wiki/Descent_theory}{\em descent data}.\index{descent data}\index{sheaf!descent data}. The way it interacts with our definition of sheaf given in Definitions~\ref{def:presheaf} and~\ref{def:sheaf} is buried in the restriction maps $\rho$ for the overlaps as subsets $U_{i,j}\subseteq U_i$ and $U_{i,j}\subseteq U_j.$ We will not explain further here. One can see \cite{Gro}.
\end{remarkENG}

\begin{remarkRUS}
\end{remarkRUS}

\begin{applicationENG}
Consider outer space as a topological space $X.$ Different astronomers record observations. Let $C=[390,700]$ denote the set of wavelengths in the visible light spectrum (written in nanometers). Given an open subset $U\subseteq X$ let ${ğ“}(U)$ denote the set of functions $U{â†’} C.$ The presheaf ${ğ“}$ satisfies the sheaf condition; this is the taken-for-granted fact that we can patch together different \href{http://en.wikipedia.org/wiki/Astrophotography}{\text observations of space}.

Below are three views of the night sky. Given a telescope position to obtain the first view, one moves the telescope right and a little down to obtain the second and one moves it down and left to obtain the third.
\footnote{Image credit: NASA, ESA, Digitized Sky Survey Consortium.}
\begin{center}\parbox{5.5in}{\begin{center}
\includegraphics[height=6cm]{Sky1}\hsp
\includegraphics[height=6cm]{Sky2}\end{center}
\hspace{1.8in}
\includegraphics[height=6cm]{Sky3}}\end{center}
These are value-assignments $a_1\in{ğ“}(V_1), a_2\in{ğ“}(V_2),$ and $a_3\in{ğ“}(V_3)$ throughout subsets $V_1,V_2,V_3\subseteq X$ (respectively). These subsets $V_1,V_2,V_3$ cover some (strangely-shaped) subset $U\subseteq X.$ The sheaf condition says that these three value-assignments glue together to form a single value-assignment throughout $U$:
\begin{center}
\includegraphics[height=7.5cm]{sky123}
\end{center}
\end{applicationENG}

\begin{applicationRUS}
\end{applicationRUS}

\begin{exerciseENG}
Find an application of sheaves in your own domain of expertise.
\end{exerciseENG}

\begin{exerciseRUS}
\end{exerciseRUS}

\begin{applicationENG}
Suppose we have a sheaf for temperatures on earth. For every region $U$ we have a set of theoretically possible temperature-assignments throughout $U.$ For example we may know that if it is warm in Texas, warm in Arkansas, and warm in Kansas, then it cannot be cold in Oklahoma. With such a sheaf ${ğ“}$ in hand, one can use facts about the temperature in one region $U$ to predict the temperature in another region $V.$ 

The mathematics is as follows. Suppose given regions $U,V\subseteq X$ and a subset $A\subseteq{ğ“}(U)$ corresponding to what we know about the temperature assignment throughout $U.$ We take the following fiber product
$$
\xymatrix{(\rho_{U,X})^{{-1}}(A)\ullimit\ar[r]\ar[d]&{ğ“}(X)\ar[d]^{\rho_{U,X}}\ar[r]^{\rho_{V,X}}&{ğ“}(V)\\
A\ar[r]&{ğ“}(U)}
$$
The image of the top map is a subset of ${ğ“}(V)$ telling us which temperature-assignments are possible throughout $V$ given our knowledge $A$ about the temperature throughout $U.$

We can imagine the same type of prediction systems for other domains as well, such as the energy of various parts of a material.
\end{applicationENG}

\begin{applicationRUS}
\end{applicationRUS}

\begin{exampleENG}
In Exercises~\ref{exc:juris 1} and~\ref{exc:juris 2} we discussed the idea of laws being dictated or respected throughout a jurisdiction. If $X$ is earth, to every jurisdiction $U\subseteq X$ we assign the set ${ğ“}(U)$ of laws that are dictated to hold throughout $U.$ Given a law on $U$ and a law on $V,$ we can see if they amount to the same law on $U\cap V.$ For example, on $U$ a law  might say â€œno hunting near riversâ€ and on $V$ a law might say â€œno hunting in public areasâ€. It just so happens that on $U\cap V$ all public areas are near rivers and vice versa, so the laws agree there. These laws patch together to form a single rule about hunting that is enforced throughout the union $U\cup V,$ respected by all jurisdictions within it.
\end{exampleENG}

\begin{exampleRUS}
\end{exampleRUS}

%% Subsubsection %%

\subsubsection{\caseENGRUS{Sheaf of ologged concepts}{ / }{ĞŸÑƒÑ‡Ğ¾Ğº ĞºĞ¾Ğ½Ñ†ĞµĞ¿Ñ‚Ğ¾Ğ² Ğ¾Ğ»Ğ¾Ğ³Ğ°}}

\begin{blockENG}
Definition~\ref{def:sheaf} defines what should be called a sheaf of sets. We can discuss sheaves of groups or even sheaves of categories. Here is an application of the latter.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{blockENG}
Recall the notion of simplicial complexes discussed in Section~\ref{sec:simplicial complex}\index{simplicial complex}. They look like this: 
\begin{align}\label{dia:olog network}
\includegraphics[height=3in]{OlogNetwork5}
\end{align} 
Given such a simplicial complex $X,$ we can imagine each vertex $v\in X_0$ as an entity with a worldview (e.g. a person) and each simplex as the common worldview shared by its vertices. To model this, we will assign to each vertex $v\in X$ an olog ${ğ“}(v),$ corresponding to the worldview held by that entity, and to each simplex $u\in X_n,$ we assign an olog ${ğ“}(u)$ corresponding to a {\em common ground} worldview.\index{common ground}. Recall that $X$ is a subset of ${â„™}(X_0)$; it is a preorder and its elements (the simplices) are ordered by inclusion. If $u,v$ are simplices with $u\subseteq v$ then we want a map of ologs (i.e. a schema morphism) ${ğ“}(v){â†’}{ğ“}(u)$ corresponding to how any idea that is shared among the people in $v$ is shared among the people in $u.$ Thus we have a functor ${ğ“}\colon X{â†’}\Sch$ (where we are forgetting the distinction between ologs and databases for notational convenience).
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{blockENG}
To every simplicial complex (indeed every ordered set) one can associate a topological space; in fact we have a functor $Alx\colon\PrO{â†’}\Top,$\index{a functor!$\PrO{â†’}\Top$} called the \href{http://en.wikipedia.org/wiki/Alexandrov_topology}{\text Alexandrov} functor. Applying $Alx(X\op)$ we have a space which we denote by ${ğ“§}.$ One can visualize ${ğ“§}$ as $X,$ but the open sets include unions of simplices. There is a unique sheaf of categories on ${ğ“§}$ that behaves like $X$ on simplices.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{blockENG}
How does this work in the case of our sheaf ${ğ“}$ of worldviews?\index{olog!sheaf of} For simplices such as $(A)$ or $(CI),$ the sheaf returns the olog corresponding to that person or shared worldview. But for open sets like the union of $(CIJ)$ and $(IJK),$ what we get is the olog consisting of the types shared by $C, I,$ and $J$ for which $I$ and $J$ affirm agreement with types shared by $I, J,$ and $K.$
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{exampleENG}
Imagine two groups of people $G_1$ and $G_2$ each making observations about the world. Suppose that there is some overlap $H=G_1\cap G_2.$ Then it may happen that there is a conversation including $G_1$ and $G_2$ and both groups are talking about something and, although using different words, $H$ says â€œyou guys are talking about the same things, you just use different words.â€ In this case there is an object-assignment throughout $G_1\cup G_2$ that agrees with both those on $G_1$ and those on $G_2.$
\end{exampleENG}

\begin{exampleRUS}
\end{exampleRUS}

%% Subsubsection %%

\subsubsection{\caseENGRUS{Time}{ / }{Ğ’Ñ€ĞµĞ¼Ñ}}

\begin{blockENG}
One can use sheaves to model objects in time; Goguen gave an approach to this in \cite{Gog}. For another approach, let ${ğ“’}$ be a database schema. The lifespan of information about the world is generally finite; that is, what was true yesterday is not always the case today. Thus we can associate to each interval $U$ of time the information that we deem to hold throughout $U.$ This is sometimes called the {\em valid time}\index{data!valid time} of the data.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{blockENG}
If something is the case throughout $U$ and we have a subset $V\subseteq U$ then of course it is the case throughout $V.$ And the sheaf condition holds too: if some information holds throughout $U$ and some other information holds throughout $U',$ and if these two things restrict to the same information on the overlap $U\cap V,$ then they can be glued to information that holds throughout the union $U\cup V.$
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{blockENG}
So we can model information-change over time by using a sheaf of ${ğ“’}$-sets on the topological space ${â„}.$ One way to think of this is simply as an instance on the schema ${ğ“’}\times\Op({â„})\op.$ The sheaf condition is just an added property that our instances have to obey.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\begin{exampleENG}
Consider a hospital in which babies are born. In our scenario, mothers enter the hospital, babies are born, mothers and babies leave the hospital. Let ${ğ“’}$ be the schema 
$$\fbox{\xymatrix{\obox{c}{.5in}{a baby}\LA{rr}{was birthed by}&\hspace{.2in}&\obox{m}{.6in}{a mother}}}$$
Consider the 8-hour intervals 
\begin{align*}
\tn{Shift}_1&{\coloneqq}(\tn{Jan }1 - 00:00,\tn{ Jan }1 - 08:00),\\
\tn{Shift}_2&{\coloneqq}(\tn{Jan }1 - 04:00,\tn{ Jan }1 - 12:00),\\
\tn{Shift}_3&{\coloneqq}(\tn{Jan }1 - 8:00,\tn{ Jan }1 - 16:00).
\end{align*}
The nurses take shifts of 8 hours, overlapping with their predecessors by 4 hours, and they record in the database only patients that were there throughout their shift or throughout any overlapping shift. A mother might be in the hospital throughout shift 1, arriving before the new year. A baby is born at 05:00 on Jan 1, and thus does not make it into the $\tn{Shift}_1$-table, but does make it into the $(\tn{Shift}_1\cap\tn{Shift}_2)$-table. The two are there until 17:00 on Jan 1, and so they are recorded in the $\tn{Shift}_2$ and $\tn{Shift}_3$ tables. 
\end{exampleENG}

\begin{exampleRUS}
\end{exampleRUS}

\begin{blockENG}
Whether or not this implementation of the sheaf semantics is most useful in practice is certainly debatable. But something like this could easily be useful as a semantics, i.e. a way of thinking about, the temporal nature of data.
\end{blockENG}

\begin{blockRUS}
\end{blockRUS}

\end{document}
